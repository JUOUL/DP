最大子数组问题：一个包含n个整数（有正有负）的数组A，设计一O(nlogn)算法找出和最大的非空连续子数组。（例如：[0, -2, 3, 5, -1, 2]应返回9，[-9, -2, -3, -5, -3]应返回-2。）

最大子数组问题可以使用分治算法或动态规划来解决。这里介绍使用动态规划的方法。

我们引入状态变量dp(i)，表示以第i个元素结尾的最大子数组和。有两种情况：

第i个元素单独构成一个新的子数组，此时dp(i) = A[i]；
第i个元素接在前面一个最大子数组的后面，此时dp(i) = dp(i-1) + A[i]。
因此，动态转移方程为：
dp(i) = max(A[i], dp(i-1) + A[i])

最终答案为所有dp(i)中的最大值。

以下是C++代码实现：

const int MAXN = ...; // 最大数组长度
int A[MAXN]; // 数组A
int dp[MAXN]; // 状态数组

int main() {
    int n;
    // 读入n和数组A

    dp[0] = A[0];
    int ans = dp[0];
    for (int i = 1; i < n; i++) {
        dp[i] = max(A[i], dp[i-1] + A[i]);
        ans = max(ans, dp[i]);
    }

    return ans;
}
时间复杂度为O(n)，空间复杂度为O(n)。
