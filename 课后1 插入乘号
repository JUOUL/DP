给出N个1-9的数字 (v1,v2,…,vN)，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。并说明其具有优化子结构性质及子问题重叠性质。
例如： N=5, K=2，5个数字分别为1、2、3、4、5，可以加成： 
1*2*(3+4+5)=24 
1*(2+3)*(4+5)=45 
(1*2+3)*(4+5)=45


dp[i][j] = max(dp[k][j-1]*(vi + ... + v(i-1)))
